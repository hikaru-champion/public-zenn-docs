---
title: ""
emoji: "📌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
# はじめに
こんにちは。championです。
普段は、Google CloudやAWSを中心としたクラウドインフラの設計～保守運用を行なっています。

個人的に年明けからコンテナ技術に再入門使用という企画をやっています。
Google CloudのCloud Runや、AWSのECSでも利用されるDockerという技術ですが、Dockerについて再度復習を兼ねてまとめたいと思います。

# Dockerとは
DockerはDocker社が開発をしており、アプリケーションとその実行に必要な環境を一つにパッケージ化し、軽量で可搬性の高い実行環境を提供するコンテナ型仮想技術です。基本的には、Dockerエンジンと呼ばれるDockerコンテナを管理するためのソフトウェアをインストールさえしていれば、様々な環境でDockerコンテナを実行することができます。そのため、Dockerは開発環境の差異を吸収してくれ、環境の一貫性を保つことができます。

# 仮想マシンとの違い
コンテナと仮想マシンは、両方それぞれの中に独立したプロセス実行環境を提供する点は同じですが、プロセスの下にあるカーネル以下のレイヤに大きな違いがある
ります。仮想マシンは、個々の仮想マシンは専用の仮想的なハードウェアとカーネルを使うのに対して、コンテナの場合は、コンテナを動かすホストOS、および全コンテナが1つのカーネルを共有します。

仮想マシンが起動するまでの流れは以下の通りですが、

1. ホストOS上の仮想化ソフトウェアが、仮想マシンを起動する。
2. GRUBなどのブートローダが起動する
3. ブートローダがカーネルを起動する
4. カーネルがinitプログラムを起動する
5. init（systemd）プロセスが各種サービスを立ち上げる

コンテナが起動するまでの流れは以下の通りです。
1. コンテナランタイム(Dockerd)が、コンテナを作る
2. コンテナが最初のプロセスを立ち上げる

仮想マシンと比較すると、起動するまでの過程がかなり短いことがわかります。
そのため、コンテナは起動時間が短いことから、迅速なスケーリングが可能になります。


# Dockerのアーキテクチャ
Dockerのアーキテクチャは、**クライアント・サーバ型**のアーキテクチャを採用しています。
![Dockerのアーキテクチャ](/images/docker-20250125/docker-architecture.png)
https://docs.docker.jp/get-started/overview.html#docker-architecture

Dockerのアーキテクチャに登場する用語について解説していきます。

## Dockerクライアント
Dockerクライアントは、Dockerデーモンとやり取りするためにユーザが利用します。**docker**CLIコマンドを実行することで、Dockerデーモンに対してDockerの機能の実行を命令します。

## Dockerデーモン
Dockerデーモンは、Dockerクライアントから命令を受け付け、Dockerイメージ、コンテナ、ネットワークなどのDockerの機能群を管理・実行します。

## Dockerレジストリ
Dockerレジストリは、**Dockerイメージ**を管理します。**Docker Hub**のような公開レジストリもあれば、AWSやGoogle Cloudのようなクラウドサービスが提供するレジストリや、プライベートレジストリも使用することができます。
Dockerデーモンは、DockerレジストリからDockerイメージを取得して、ホスト上でDockerイメージからDockerコンテナを実行します。

## Dockerイメージ
Dockerイメージは、Dockerコンテナを作成する命令が記載されているテンプレートのことを言います。DockerコンテナはDockerイメージをもとに作成されます。Dockerイメージは、先述したDockerレジストリからダウンロードすることもできますし、自身で作成することもできます。自身でDockerイメージを作成する場合は、**Dockerfile**というファイルを作成し、DockerfileにDockerイメージを作成するまでの命令を記載します。

## Dockerコンテナ
Dockerコンテナは、先述したDockerイメージから作成される実行状態となったインスタンスのことを言います。コンテナは、Linuxカーネルの機能を利用して独立したネットワークや、プロセスが提供されホストマシン上で隔離された領域になります。


# dockerのインストール
Rocky LinuxにDockerをインストールしていきます。

## Dockerリポジトリの追加
Docker社が提供する公式のリポジトリを追加していきます。
```bash
$ sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
Adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
```

リポジトリ一覧を確認していきます。
```bash
$ sudo dnf repolist | grep Docker
docker-ce-stable                      Docker CE Stable - x86_64
```
これでRocky LinuxにDockerのリポジトリがインストールできました。

## Dockerエンジンのインストール
Dockerエンジンを以下のコマンドでインストールしていきます。
```bash
$ sudo dnf -y install docker-ce docker-ce-cli containerd.io
```
インストール後、**docker version**コマンドを実行することで、インストールしたDockerのバージョンを表示することができます。
今回はバージョン**27.5.1**がインストールされていることが確認できました。
```bash
$ docker version
Client: Docker Engine - Community
 Version:           27.5.1
 API version:       1.47
 Go version:        go1.22.11
 Git commit:        9f9e405
 Built:             Wed Jan 22 13:42:47 2025
 OS/Arch:           linux/amd64
 Context:           default
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
```

## Dockerの起動確認と自動起動設定
Dockerエンジンインストール直後は、Dockerデーモンが起動していません。
```bash
$ sudo systemctl status docker
○ docker.service - Docker Application Container Engine
     Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; preset: disabled)
     Active: inactive (dead)
TriggeredBy: ○ docker.socket
       Docs: https://docs.docker.com
```

そのため、**systemctl start**コマンドを利用して、Dockerの起動を行っていきます。
```bash
$ sudo systemctl start docker
$ sudo systemctl status docker
● docker.service - Docker Application Container Engine
     Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; preset: disabled)
     Active: active (running) since Fri 2025-01-24 23:17:49 UTC; 1s ago
TriggeredBy: ● docker.socket
       Docs: https://docs.docker.com
   Main PID: 78229 (dockerd)
      Tasks: 10
     Memory: 28.2M
        CPU: 207ms
     CGroup: /system.slice/docker.service
             └─78229 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

Jan 24 23:17:47 rocky dockerd[78229]: time="2025-01-24T23:17:47.956118145Z" level=info msg="Starting up"
Jan 24 23:17:47 rocky dockerd[78229]: time="2025-01-24T23:17:47.957371649Z" level=info msg="OTEL tracing is not>
Jan 24 23:17:48 rocky dockerd[78229]: time="2025-01-24T23:17:48.019630565Z" level=info msg="Loading containers:>
Jan 24 23:17:48 rocky dockerd[78229]: time="2025-01-24T23:17:48.059542785Z" level=info msg="Firewalld: created >
Jan 24 23:17:49 rocky dockerd[78229]: time="2025-01-24T23:17:49.309172007Z" level=info msg="Firewalld: interfac>
Jan 24 23:17:49 rocky dockerd[78229]: time="2025-01-24T23:17:49.642863119Z" level=info msg="Loading containers:>
Jan 24 23:17:49 rocky dockerd[78229]: time="2025-01-24T23:17:49.664401585Z" level=info msg="Docker daemon" comm>
Jan 24 23:17:49 rocky dockerd[78229]: time="2025-01-24T23:17:49.664710505Z" level=info msg="Daemon has complete>
Jan 24 23:17:49 rocky dockerd[78229]: time="2025-01-24T23:17:49.716290617Z" level=info msg="API listen on /run/>
Jan 24 23:17:49 rocky systemd[1]: Started Docker Application Container Engine.
```

Dockerの起動が確認できた後は、再起動後も自動的にDockerデーモンが起動するように、**systemctl enable**コマンドを利用して自動起動の設定を行なっていきます。

```bash
$ sudo systemctl enable docker
Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/system/docker.service.

$ sudo systemctl is-enabled docker
enabled
```

## Dockerグループへユーザーを追加
Dockerインストール時は、dockerコマンドはroot権限でしか実行できません。**docker ps**コマンドを実行すると、**/var/run/docker.sock**ファイルへの権限エラーになってしまいます。
**/var/run/docker.sock**ファイルの権限を確認すると、rootかdockerグループのメンバーにしか権限がないことがわかります。

```bash
$ docker ps
permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get "http://%2Fvar%2Frun%2Fdocker.sock/v1.47/containers/json": dial unix /var/run/docker.sock: connect: permission denied


$ ll /var/run/docker.sock 
srw-rw----. 1 root docker 0 Jan 24 23:17 /var/run/docker.sock
```
root以外でもdockerコマンドを実行することができるように設定していきます。
自身のユーザをdockerグループに所属させることで、自身のユーザでdockerコマンドを実行することができます。
```bash
$ sudo usermod -aG docker $USER
```
その後、再起動して再度ログインした後に**docker ps**コマンドを実行すると、権限エラーがなく実行結果を表示することができました。
```bash
$ sudo reboot

$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```
これでdockerを使用できる環境は整いました。
次にdockerを実際に動作させてみて、各種コマンドを実行した際に何が起こるのかを説明していきます。

# Dockerの基本コマンド
## コンテナイメージの管理
Dockerコンテナを作成するためには、コンテナのもととなるイメージが必要です。コンテナイメージがホストしてあるパブリックレジストリのDocker Hubからイメージを取得してみましょう。

### コンテナイメージの取得
**docker image pull**コマンドを利用することで、イメージをローカルに取得することができます。
```bash
$ docker image pull nginx
Using default tag: latest
latest: Pulling from library/nginx
af302e5c37e9: Pull complete 
207b812743af: Pull complete 
841e383b441e: Pull complete 
0256c04a8d84: Pull complete 
38e992d287c5: Pull complete 
9e9aab598f58: Pull complete 
4de87b37f4ad: Pull complete 
Digest: sha256:0a399eb16751829e1af26fea27b20c3ec28d7ab1fb72182879dcae1cca21206a
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest
```

### コンテナイメージの確認
**docker image ls**コマンドを利用することで、ローカルのイメージを確認することができます。
先ほど取得したnginxイメージが確認できます。
```bash
$ docker image ls -a
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    9bea9f2796e2   2 months ago   192MB
```

### コンテナイメージの詳細確認
**docker image inspect**コマンドを利用することで、イメージの詳細情報を確認することができます。
先ほど取得したnginxイメージの詳細情報を確認できます。
```bash
$ docker image inspect nginx
[
    {
        "Id": "sha256:9bea9f2796e236cb18c2b3ad561ff29f655d1001f9ec7247a0bc5e08d25652a1",
        "RepoTags": [
            "nginx:latest"
        ],
        "RepoDigests": [
            "nginx@sha256:0a399eb16751829e1af26fea27b20c3ec28d7ab1fb72182879dcae1cca21206a"
        ],
        "Parent": "",
        "Comment": "buildkit.dockerfile.v0",
        "Created": "2024-11-26T18:42:08Z",
        "DockerVersion": "",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "80/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "NGINX_VERSION=1.27.3",
                "NJS_VERSION=0.8.7",
                "NJS_RELEASE=1~bookworm",
                "PKG_RELEASE=1~bookworm",
                "DYNPKG_RELEASE=1~bookworm"
            ],
            "Cmd": [
                "nginx",
                "-g",
                "daemon off;"
            ],
            "Image": "",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": [
                "/docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>"
            },
            "StopSignal": "SIGQUIT"
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 191717838,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/c62106fa57349d94eba4e963b21800c22f8a52eab4590791913f1e7b8267b19d/diff:/var/lib/docker/overlay2/e5e14a96d8c8b642b1fc7d10fba4fc2cd655393d064110f1586df8da55df67e3/diff:/var/lib/docker/overlay2/1acda929ef130c2d441400007789f5a200c28f44cc7a329d69af92a5a34b4b26/diff:/var/lib/docker/overlay2/a97d6d46ca7cfdc6356a17cf13e50926900c1447e50a780a3aa7da5076d4a119/diff:/var/lib/docker/overlay2/f647c002739a739b7ab5a917f9dac86d0a92b578fa2148435279a686cb44cc9f/diff:/var/lib/docker/overlay2/f0bbaa46d35f96c04648c3200aa7bc376cd762a90f565725fcdd8fb51fb9c6cf/diff",
                "MergedDir": "/var/lib/docker/overlay2/9af8df103a8f7396f513e37bfa98ed46a2f77d1fcba4984756c94ed221f7da65/merged",
                "UpperDir": "/var/lib/docker/overlay2/9af8df103a8f7396f513e37bfa98ed46a2f77d1fcba4984756c94ed221f7da65/diff",
                "WorkDir": "/var/lib/docker/overlay2/9af8df103a8f7396f513e37bfa98ed46a2f77d1fcba4984756c94ed221f7da65/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:f5fe472da25334617e6e6467c7ebce41e0ae5580e5bd0ecbf0d573bacd560ecb",
                "sha256:88ebb510d2fb3ed50f4268455a38443074cad5c6957f6d2cd0126c899a159e6e",
                "sha256:9431321431991c4e64246007e04602160bca8984439ff96461fb992072dd49af",
                "sha256:32c977818204dc910140b3b7abcad06a6613dd1f511ce8f33626a364a3bb68b6",
                "sha256:541cf9cf006d6c9920e5897bf63a4dce0ae1a8388bc82bfa1abedc48b8eb1de9",
                "sha256:58045dd06e5b2c1220ab200c36b450ce3adbfd3fa0f8e3c2c17ffaf7f2906455",
                "sha256:b57b5eac2941c7c1f1f5bc2391123e553d0082eb8e1c6675101aab47a11b26ee"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

### コンテナイメージの履歴の確認
**docker image history**コマンドを利用することで、イメージの履歴情報を確認することができます。
先ほど取得したnginxイメージの履歴情報を確認できます。
```bash
$ docker image history nginx
IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
9bea9f2796e2   2 months ago   CMD ["nginx" "-g" "daemon off;"]                0B        buildkit.dockerfile.v0
<missing>      2 months ago   STOPSIGNAL SIGQUIT                              0B        buildkit.dockerfile.v0
<missing>      2 months ago   EXPOSE map[80/tcp:{}]                           0B        buildkit.dockerfile.v0
<missing>      2 months ago   ENTRYPOINT ["/docker-entrypoint.sh"]            0B        buildkit.dockerfile.v0
<missing>      2 months ago   COPY 30-tune-worker-processes.sh /docker-ent…   4.62kB    buildkit.dockerfile.v0
<missing>      2 months ago   COPY 20-envsubst-on-templates.sh /docker-ent…   3.02kB    buildkit.dockerfile.v0
<missing>      2 months ago   COPY 15-local-resolvers.envsh /docker-entryp…   389B      buildkit.dockerfile.v0
<missing>      2 months ago   COPY 10-listen-on-ipv6-by-default.sh /docker…   2.12kB    buildkit.dockerfile.v0
<missing>      2 months ago   COPY docker-entrypoint.sh / # buildkit          1.62kB    buildkit.dockerfile.v0
<missing>      2 months ago   RUN /bin/sh -c set -x     && groupadd --syst…   117MB     buildkit.dockerfile.v0
<missing>      2 months ago   ENV DYNPKG_RELEASE=1~bookworm                   0B        buildkit.dockerfile.v0
<missing>      2 months ago   ENV PKG_RELEASE=1~bookworm                      0B        buildkit.dockerfile.v0
<missing>      2 months ago   ENV NJS_RELEASE=1~bookworm                      0B        buildkit.dockerfile.v0
<missing>      2 months ago   ENV NJS_VERSION=0.8.7                           0B        buildkit.dockerfile.v0
<missing>      2 months ago   ENV NGINX_VERSION=1.27.3                        0B        buildkit.dockerfile.v0
<missing>      2 months ago   LABEL maintainer=NGINX Docker Maintainers <d…   0B        buildkit.dockerfile.v0
<missing>      2 months ago   # debian.sh --arch 'amd64' out/ 'bookworm' '…   74.8MB    debuerreotype 0.15
```

### コンテナイメージへのタグ付け
**docker image tag**コマンドを利用することで、イメージへタグを付与することができます。
先ほど取得したnginxイメージへv1タグを付与して見ます。
```bash
$ docker image tag nginx:latest nginx:v1
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    9bea9f2796e2   2 months ago   192MB
nginx        v1        9bea9f2796e2   2 months ago   192MB
```

### コンテナイメージの削除
**docker image rm**コマンドを利用することで、特定のイメージや複数イメージを削除することができます。
```bash
$ docker image rm nginx
Untagged: nginx:latest
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        v1        9bea9f2796e2   2 months ago   192MB
```

また、**docker image prune**コマンドを利用することで、使用されていないコンテナイメージをすべて削除することができます。
```bash
$ docker image rm nginx
Untagged: nginx:latest
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        v1        9bea9f2796e2   2 months ago   192MB

$ docker image prune -a
WARNING! This will remove all images without at least one container associated to them.
Are you sure you want to continue? [y/N] y
Deleted Images:
untagged: nginx:v1
untagged: nginx@sha256:0a399eb16751829e1af26fea27b20c3ec28d7ab1fb72182879dcae1cca21206a
deleted: sha256:9bea9f2796e236cb18c2b3ad561ff29f655d1001f9ec7247a0bc5e08d25652a1
deleted: sha256:ad858b4eee2d8f479065d1b8c650e13c815e75b2e4503c05a67cdc8880b0975a
deleted: sha256:a8d62a6e94dbe8920ecfafa3b3aff0ef70aa26ca929f90b110db998eec09bab5
deleted: sha256:8ad081ee0d46efdea0492cd0bb527c50a8891276fd408ec1269522ac9d6d5580
deleted: sha256:d9ff8651e34fffb11d2a29317ec8404dcd4481bfcc1883b495113365dba8a461
deleted: sha256:d351808aa3da5992f01a613745394c289e51a673d7809800322475b413e627e4
deleted: sha256:5ec183755d09a0a54d0f83e5a705f28f1606fe75660c13148fe125e4f12af39f
deleted: sha256:f5fe472da25334617e6e6467c7ebce41e0ae5580e5bd0ecbf0d573bacd560ecb

Total reclaimed space: 191.7MB
$ docker image ls
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
```


## コンテナの管理
**docker container**コマンドは、コンテナを管理する基本コマンドです。

### コンテナの作成
コンテナを作成するためには、**docker container create**コマンドを実行します。
取得したnginxイメージからnginxコンテナを作成してみましょう。
```bash
$ docker container create -it --name nginx nginx
7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82
```

### コンテナの確認
コンテナを一覧表示して確認するためには、**docker container ls**コマンドを実行します。
デフォルトでは、実行中のコンテナのみ表示するので、すべてのコンテナを表示するためには**-a**オプションを付与します。
```bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS    PORTS     NAMES
7b133740fabb   nginx     "/docker-entrypoint.…"   27 seconds ago   Created             nginx
```

### コンテナの起動
作成したコンテナを起動するためには、**docker container start**コマンドを実行します。
先ほど作成したnginxコンテナを起動します。
```bash
$ docker container start nginx
nginx
$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
7b133740fabb   nginx     "/docker-entrypoint.…"   5 minutes ago   Up 5 seconds   80/tcp    nginx
```

### コンテナの一時停止
作成したコンテナの一時停止をするためには、**docker container pause**コマンドを実行します。
先ほど作成したnginxコンテナを一時停止します。STATUSが**Paused**になっていることが確認できます。
```bash
$ docker container pause nginx
nginx
$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                  PORTS     NAMES
7b133740fabb   nginx     "/docker-entrypoint.…"   9 minutes ago   Up 3 minutes (Paused)   80/tcp    nginx
```

### コンテナの一時停止の解除
作成したコンテナの一時停止を解除するためには、**docker container unpause**コマンドを実行します。
先ほど作成したnginxコンテナの一時停止を解除します。STATUSの**Paused**がなくなっていることが確認できます。

```bash
$ docker container unpause nginx
nginx
$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS         PORTS     NAMES
7b133740fabb   nginx     "/docker-entrypoint.…"   15 minutes ago   Up 9 minutes   80/tcp    nginx
```

### コンテナのログ確認
起動しているコンテナのログを確認するためには、**docker container logs**コマンドを実行します。
先ほど作成したnginxコンテナのログを確認します。

```bash
$ docker container logs nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2025/01/28 01:04:27 [notice] 1#1: using the "epoll" event method
2025/01/28 01:04:27 [notice] 1#1: nginx/1.27.3
2025/01/28 01:04:27 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14) 
2025/01/28 01:04:27 [notice] 1#1: OS: Linux 5.14.0-503.21.1.el9_5.x86_64
2025/01/28 01:04:27 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1073741816:1073741816
2025/01/28 01:04:27 [notice] 1#1: start worker processes
2025/01/28 01:04:27 [notice] 1#1: start worker process 29
2025/01/28 01:04:27 [notice] 1#1: start worker process 30
```

### コンテナのログ確認
起動しているコンテナのログを確認するためには、**docker container logs**コマンドを実行します。
先ほど作成したnginxコンテナのログを確認します。

```bash
$ docker container logs nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2025/01/28 01:04:27 [notice] 1#1: using the "epoll" event method
2025/01/28 01:04:27 [notice] 1#1: nginx/1.27.3
2025/01/28 01:04:27 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14) 
2025/01/28 01:04:27 [notice] 1#1: OS: Linux 5.14.0-503.21.1.el9_5.x86_64
2025/01/28 01:04:27 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1073741816:1073741816
2025/01/28 01:04:27 [notice] 1#1: start worker processes
2025/01/28 01:04:27 [notice] 1#1: start worker process 29
2025/01/28 01:04:27 [notice] 1#1: start worker process 30
```

### コンテナ内でのコマンド実行
起動しているコンテナ内でコマンドを実行するためには、**docker container exec**コマンドを実行します。
先ほど作成したnginxコンテナ内で**ls**コマンドを実行してみます。
```bash
$ docker container exec nginx /bin/ls
bin
boot
dev
docker-entrypoint.d
docker-entrypoint.sh
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
```

### コンテナの詳細情報の確認
起動しているコンテナの詳細情報を確認するためには、**docker container inspect**コマンドを実行します。
先ほど作成したnginxコンテナの詳細情報を確認してみます。
```bash
$ docker container inspect nginx
[
    {
        "Id": "7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82",
        "Created": "2025-01-28T00:58:55.588075253Z",
        "Path": "/docker-entrypoint.sh",
        "Args": [
            "nginx",
            "-g",
            "daemon off;"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 8712,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2025-01-28T01:04:26.813199789Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:9bea9f2796e236cb18c2b3ad561ff29f655d1001f9ec7247a0bc5e08d25652a1",
        "ResolvConfPath": "/var/lib/docker/containers/7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82/hostname",
        "HostsPath": "/var/lib/docker/containers/7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82/hosts",
        "LogPath": "/var/lib/docker/containers/7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82/7b133740fabbd2225449d081ab045a2ce46b70e16502379fb4e8e59c3fa40b82-json.log",
        "Name": "/nginx",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "bridge",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "ConsoleSize": [
                39,
                112
            ],
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "private",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": [],
            "BlkioDeviceWriteBps": [],
            "BlkioDeviceReadIOps": [],
            "BlkioDeviceWriteIOps": [],
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": null,
            "PidsLimit": null,
            "Ulimits": [],
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware",
                "/sys/devices/virtual/powercap"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/29cb462ba0ae5b7700fe028003880be6fe7f9b1f56b65e5ae8dae65272608cbf-init/diff:/var/lib/docker/overlay2/a67c2c59f9fd17db2d1900a928231302fb5e1f2c7dfc8df59cbd14ca495771a9/diff:/var/lib/docker/overlay2/6d814e8d9628a52eeded47e8f7572b68e21de24b47c169490fbb859ddb196b56/diff:/var/lib/docker/overlay2/8a5b34ed2e7703191b20a96d5ec387488842c043559834bfbc3d381991b3dcaf/diff:/var/lib/docker/overlay2/41586b8716f54372dd795e8b6ac8caa9c3f01082e14aeed9a6c7330fa9474940/diff:/var/lib/docker/overlay2/76ddb28f01bdcae287544c511af70941e241bb4418a9372a639ed5818fc3208e/diff:/var/lib/docker/overlay2/baf066c30d879eefda95f4586b80278efa3396650e9c92dcc7f1242c07ae9a32/diff:/var/lib/docker/overlay2/c95ee7542ec60a44101d4fca283bf13e0de284e40853b29f21e2ad4a27b58d15/diff",
                "MergedDir": "/var/lib/docker/overlay2/29cb462ba0ae5b7700fe028003880be6fe7f9b1f56b65e5ae8dae65272608cbf/merged",
                "UpperDir": "/var/lib/docker/overlay2/29cb462ba0ae5b7700fe028003880be6fe7f9b1f56b65e5ae8dae65272608cbf/diff",
                "WorkDir": "/var/lib/docker/overlay2/29cb462ba0ae5b7700fe028003880be6fe7f9b1f56b65e5ae8dae65272608cbf/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "7b133740fabb",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "ExposedPorts": {
                "80/tcp": {}
            },
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "NGINX_VERSION=1.27.3",
                "NJS_VERSION=0.8.7",
                "NJS_RELEASE=1~bookworm",
                "PKG_RELEASE=1~bookworm",
                "DYNPKG_RELEASE=1~bookworm"
            ],
            "Cmd": [
                "nginx",
                "-g",
                "daemon off;"
            ],
            "Image": "nginx",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": [
                "/docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>"
            },
            "StopSignal": "SIGQUIT"
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "881af4be43ceb546e0b79294fa651314b1c7debab017c2647793ede3baea9ff1",
            "SandboxKey": "/var/run/docker/netns/881af4be43ce",
            "Ports": {
                "80/tcp": null
            },
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "83407366cd373fb662077b8a9af58469fcb0ed64c6e0284e74c29cc594511713",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null,
                    "NetworkID": "3d66a57a65ad26769b11bb624ddd8d89b50ee8c825b9c465b12a387dcdafefc6",
                    "EndpointID": "83407366cd373fb662077b8a9af58469fcb0ed64c6e0284e74c29cc594511713",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DNSNames": null
                }
            }
        }
    }
]
```

### コンテナの停止
起動しているコンテナを停止するためには、**docker container stop**コマンドを実行します。
先ほど作成したnginxコンテナの停止してみます。STATUSが**Exited**に変更されていることがわかります。

```bash
$ docker container stop nginx
nginx

$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                     PORTS     NAMES
7b133740fabb   nginx     "/docker-entrypoint.…"   40 minutes ago   Exited (0) 6 seconds ago             nginx
```

### コンテナの削除
停止したコンテナも削除するまでは、ローカルに残ってしまいます。停止済みのコンテナを削除するには**docker container rm**コマンドを実行します。
先ほど停止したnginxコンテナを削除してみます。

```bash
$ docker container rm nginx
nginx

$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

### コンテナの実行
先ほどまで以下の手順でコンテナの説明していましたが、
- イメージの取得
- コンテナの作成
- コンテナの起動
**docker container run**コマンドを実行することで、上記の手順を一つのコマンドで実行してくれます。
nginxコンテナを**docker container run**コマンドで起動まで行っていきましょう。この時オプションでしている「-i」は、コンテナへ標準入力を行えるようにするオプションです。「-d」は、デタッチモードで起動＝バックグラウンドプロセスで起動するよう設定するオプションです。「-t」はコンテナに疑似ttyを割り当てるオプションです。これにより標準入力を行うことができます。また、「-p」オプションにより、ホスト側のポートとコンテナのポートをマッピングしています。今回はホスト側の8080ポートをコンテナのポート80へマッピングしています。つまり、ホスト側のポート8080へアクセスすると、コンテナの80ポートへフォワーディングされます。
起動したnginxコンテナへアクセスしてみます。ホスト側の8080ポートへcurlコマンドを実行してみると、nginxのトップページのhtmlが返却されたことが確認できます。
```bash
$ docker container run -dit --name nginx -p 8080:80 nginx
2a42e67572a63ced9bc354ad2463a85bad8dec427d0598d0f777e207d1aedfdd

$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                     NAMES
2a42e67572a6   nginx     "/docker-entrypoint.…"   3 seconds ago   Up 3 seconds   0.0.0.0:8080->80/tcp, [::]:8080->80/tcp   nginx

$ curl localhost:8080
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

# Dockerネットワーク
## Dockerネットワークの概要
Dockerをインストールすると、Docker専用のネットワーク空間 (172.17.0.0/16) と、ネットワークドライバがインストール時に作成されます。

```bash
$ ip address show | grep docker0
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
15: vethb9fdb2a@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 

$ ip link show | grep docker0
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
15: vethb9fdb2a@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default 

$ ip route show | grep docker0
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
```

## Dockerネットワークドライバ
Dockerのネットワークドライバには以下の6種類存在します。

| ネットワークドライバ | 機能 |
| ---- | ---- |
| bridge | コンテナ作成時に、デフォルトで使用されるネットワークドライバー。同じホスト上の他のコンテナと通信する必要があるコンテナでよく利用されます。 |
| host | コンテナと Docker ホスト間のネットワーク分離を削除し、ホストのネットワークを直接使用します。 |
| overlay | 複数の Docker デーモン間を接続し、Docker Swarmとコンテナがノード間で通信できるようにします。 |
| ipvlan |  IPv4とIPv6の両方のアドレス指定を完全に制御できます。 |
| macvlan | コンテナにMACアドレスを割り当てて、ネットワーク上の物理デバイスとして表示することができます。Dockerデーモンは、トラフィックをMACアドレスによってコンテナにルーティングします。 |
| none | コンテナをホストおよび他のコンテナから完全に分離します。 |

Dockerインストール時には、デフォルトで以下のネットワークドライバを作成しています。
```bash
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
3d66a57a65ad   bridge    bridge    local
645e777d3a0c   host      host      local
99a964c8093b   none      null      local
```

### bridgeネットワーク
bridgeネットワークは、同じネットワークセグメント間での通信を可能にするリンク層 (L2層)の仮想デバイスです。ブリッジは、通常の物理ネットワーク機器に用いられることもありますが、ソフトウェアでbridgeの機能を提供しているので仮想ブリッジと言います。bridgeネットワークは、同じbridgeネットワークに接続されたコンテナ同士は通信できるようにし、接続されていないコンテナは通信できないように自動的にホストマシンにルールを設定してくれます。

コンテナを起動するとデフォルトで**bridge**ネットワーク上に作成されます。
alpine linuxを300秒Sleepするコンテナを作成してみます。ネットワークの指定はオプションでしていないのでデフォルトの**bridge**ネットワークが利用されるはずです。
```bash
$ docker container run -d --name alpine-linux --rm alpine sleep 300

$ docker container ls
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
6f58bcd0bcea   alpine    "sleep 300"   44 seconds ago   Up 44 seconds             alpine-linux
```

**docker network inspect**コマンドを実行することで、ネットワークデバイスの詳細情報を確認することができます。bridgeネットワークの詳細を確認してみます。**Containers**の箇所を確認すると、作成したコンテナ（alpine-linux）がIPアドレス 172.17.0.3/16 としてbridgeネットワークに所属していることが確認できます。
```bash
$ docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "3d66a57a65ad26769b11bb624ddd8d89b50ee8c825b9c465b12a387dcdafefc6",
        "Created": "2025-01-24T23:45:41.480007785Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "6f58bcd0bceaf460afc31683d78e610624061a5275048c2543a8e0f869cfa026": {
                "Name": "alpine-linux",
                "EndpointID": "2ff8e5dadf8131d4956e95ac94de404cc5e12f7b3f0691dc0308573c5b21c157",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]
```

この時にホスト側のネットワーク状況を確認すると、コンテナ起動時にコンテナと通信するための仮想ネットワークインターフェースが作成されています。
```bash
$ ip address show

19: vethc6a8080@if18: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether b6:71:fd:a6:b5:9a brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet6 fe80::b471:fdff:fea6:b59a/64 scope link 
       valid_lft forever preferred_lft forever
```

これまでを図で表すと以下のような状態になっていることになります。
![bridgeネットワーク01](/images/docker-20250125/bridge-network01.drawio.png)


次に、複数のコンテナを作成したときにはどうなるでしょうか？
新しく**alpine-linux01**と**alpine-linux02**を作成してbridgeネットワークの状態を確認してみます。

```bash
$ docker container run -d --name alpine-linux01 --rm alpine sleep 300
929b7849fb1206108c6b32cbe9fa4f28b243a68f64fd9402396bcdbbe4fefb51

$ docker container run -d --name alpine-linux02 --rm alpine sleep 300
a83bab22d215f900b2e6c5271d95d3408640d0ab7531994441eaf2fb975319b2

$ docker container ls
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
a83bab22d215   alpine    "sleep 300"   5 seconds ago   Up 4 seconds             alpine-linux02
929b7849fb12   alpine    "sleep 300"   8 seconds ago   Up 8 seconds             alpine-linux01

$ docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "3d66a57a65ad26769b11bb624ddd8d89b50ee8c825b9c465b12a387dcdafefc6",
        "Created": "2025-01-24T23:45:41.480007785Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "929b7849fb1206108c6b32cbe9fa4f28b243a68f64fd9402396bcdbbe4fefb51": {
                "Name": "alpine-linux01",
                "EndpointID": "94532654b4f11232941bcb8521a45ef41c1251790ac79ea55d2c9f326a1cb4f3",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            },
            "a83bab22d215f900b2e6c5271d95d3408640d0ab7531994441eaf2fb975319b2": {
                "Name": "alpine-linux02",
                "EndpointID": "cccb8c9a7a86d0bd5dcd2cf3664fb4f35460784ebd066546f679b22aca40d445",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]
```
二つのコンテナは、bridgeネットワークに接続され、alpine-linux01には172.17.0.2/16、alpine-linux02には172.17.0.3/16のIPアドレスが設定されていることが確認できました。
これまでを図で表すと以下のような状態になっていることになります。
![bridgeネットワーク02](/images/docker-20250125/bridge-network02.drawio.png)

同じbridgeネットワークに接続されているコンテナ同士は相互に通信することが可能です。それぞれのコンテナからコンテナへpingを実行すると正常に通信できました。

```bash
$ docker container exec alpine-linux01 ping -c 3 172.17.0.3
PING 172.17.0.3 (172.17.0.3): 56 data bytes
64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.186 ms
64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.077 ms
64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.125 ms

--- 172.17.0.3 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.077/0.129/0.186 ms

$ docker container exec alpine-linux02 ping -c 3 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.074 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.124 ms
64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.097 ms

--- 172.17.0.2 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.074/0.098/0.124 ms
```

bridgeネットワークは、ユーザ自身で定義して作成することもできます。ユーザで定義して作成したbridgeネットワークでは、コンテナ間の通信に**DNSによる名前解決機能**を利用することできます。DNSによる名前解決機能を利用することでコンテナ間の通信を行う際に、IPアドレスを直接指定することなく、コンテナ名で通信を行うことができます。
また、異なるbridgeネットワークに属しているコンテナ間では、互いに通信することはできません。そのため、ネットワークを分離することで不要なコンテナ間の通信を防ぐことができ分離性が向上します。コンテナ自身はコマンド一つでネットワークに接続・切断することができます。

実際に、bridgeネットワークを作成してみましょう。ユーザ定義のネットワークを作成するためには、**docker network create**コマンドを実行します。
```bash
$ docker network create my-net --driver bridge
300b094e6d5d37d7d59719045a4e3c1ae7bdd8cd7b44097c8ef36e07cf84e051
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
3d66a57a65ad   bridge    bridge    local
645e777d3a0c   host      host      local
300b094e6d5d   my-net    bridge    local
99a964c8093b   none      null      local
```

ユーザ定義のbridgeネットワーク（my-net）を作成することができたので、詳細情報を確認していきます。**docker network inspect**コマンドを実行することで、ネットワークの詳細情報を確認することができます。
```bash
$ docker network inspect my-net
[
    {
        "Name": "my-net",
        "Id": "300b094e6d5d37d7d59719045a4e3c1ae7bdd8cd7b44097c8ef36e07cf84e051",
        "Created": "2025-01-30T20:21:36.397509121Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
```

作成したネットワーク内にコンテナを立てて、コンテナ間の通信に**DNSによる名前解決機能**を利用してみましょう。
```bash
$ docker container run -d --name alpine-linux01 --network my-net --rm alpine sleep 300 
2952b84733460370e53fd0b803145b1699bc6e23637b3d6d867b52f11e9ee8b7
$ docker container run -d --name alpine-linux02 --network my-net --rm alpine sleep 300 
759a82366abe67c17a6ff2d48501e0782e858ea0237f2f7e243df2169e201b49

$ docker container exec alpine-linux01 ping -c 3 alpine-linux02
PING alpine-linux02 (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.071 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.122 ms
64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.115 ms

--- alpine-linux02 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.071/0.102/0.122 ms

$ docker container exec alpine-linux02 ping -c 3 alpine-linux01
PING alpine-linux01 (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.139 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.088 ms
64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.231 ms

--- alpine-linux01 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.088/0.152/0.231 ms
```
DNSによる名前解決機能を利用することでコンテナ間の通信を行う際に、IPアドレスを直接指定することなく、コンテナ名を利用し通信を行うことができました。

![bridgeネットワーク03](/images/docker-20250125/bridge-network03.drawio.png)

それでは、作成したネットワーク内のコンテナと、デフォルトのbridgeネットワーク内のコンテナ間の通信はどうなるでしょうか？
作成したネットワーク内のコンテナから、デフォルトのbridgeネットワーク内のコンテナへの通信は、**ping: bad address 'alpine-linux03'**と表示され、**DNSによる名前解決機能**が利用できませんでした。また、IPアドレスを直指定しての通信もできないことがわかりました。これにより、異なるbridgeネットワークに属しているコンテナ間では、互いに通信することはできないことが確認できました。

```bash
$ docker container run -d --name alpine-linux03 --rm alpine sleep 300 
52b3da9559a35953c829742cd452142e66fc8abed6f8ffb2242d055b7bd74695

$ docker container exec alpine-linux02 ping -c 3 alpine-linux03
ping: bad address 'alpine-linux03'

$ docker container exec alpine-linux01 ping -c 3 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes

--- 172.17.0.2 ping statistics ---
3 packets transmitted, 0 packets received, 100% packet loss
```
![bridgeネットワーク04](/images/docker-20250125/bridge-network04.drawio.png)

自身で作成したネットワークを削除したい場合は、**docker network rm**コマンドを実行します。
```bash
$ docker network rm my-net
my-net

$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
3d66a57a65ad   bridge    bridge    local
645e777d3a0c   host      host      local
99a964c8093b   none      null      local
```

### hostネットワーク
hostネットワークは、dockerホスト側のネットワークを利用することになります。コンテナをhostネットワークに接続した場合、dockerホスト側のネットワークと同じ設定になります。コンテナ自身にはIPアドレスは付与されず、またポートの割当ても無効になります。nginxコンテナをhostネットワークに接続することで、dockerホストのIPアドレス、ポート80でnginxが起動します。そのため、curlコマンドを**localhost:80**に実行することでnginxのhtmlが返ってきます。

![hostネットワーク](/images/docker-20250125/host-network.drawio.png)

```bash
$ docker container run -d --name nginx --network host nginx 
95a8a17597590d09e4f62e1e43e54dcdaec54b9241469bb44617454babeb6402

$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
95a8a1759759   nginx     "/docker-entrypoint.…"   4 seconds ago    Up 3 seconds              nginx

$ curl localhost:80
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

### noneネットワーク
noneネットワークは、コンテナのネットワーク機能を無効化し、完全に独立した状態にすることができます。コンテナ自身にIPアドレスは割り振られず、コンテナ間の通信や、外部のインターネットに通信をしたりすることはできません。
noneネットワークに接続しているコンテナ内で**各種ipコマンド**を実行するとループバックインターフェースしか存在せず、ルートテーブルは存在しないです。また、IPアドレス8.8.8.8へpingコマンドを実行しても**Network unreachable**と表示され隔離されていることがわかります。

![noneネットワーク](/images/docker-20250125/none-network.drawio.png)

```bash
$ docker container run -d --name alpine-linux01 --network none --rm alpine sleep 300 
e9b82e397e550835c369013cbcc9ab1a046e670f908aeecef54f7751ec53d0f8

$ docker network inspect none
[
    {
        "Name": "none",
        "Id": "99a964c8093b7b0b10eb5d43f643f6f5831456bb18f01a9d1aee2230eb5a89cc",
        "Created": "2025-01-24T23:17:48.861986575Z",
        "Scope": "local",
        "Driver": "null",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": null
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "e9b82e397e550835c369013cbcc9ab1a046e670f908aeecef54f7751ec53d0f8": {
                "Name": "alpine-linux01",
                "EndpointID": "139b7879587a0481cde520ead77e3a3b083171c8ead5ce902ceaeecac34dce7d",
                "MacAddress": "",
                "IPv4Address": "",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
$ docker container exec alpine-linux01 ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00

$ docker container exec alpine-linux01 ip address show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever

$ docker container exec alpine-linux01 ip route show

$ docker container exec alpine-linux01 ping -c 3 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
ping: sendto: Network unreachable
```

# Docker Storage
## Dockerでのデータ管理方法
Dockerコンテナ内で作成されたファイル等のデータは、コンテナが削除されると一緒に消えてしまいます。これはLinuxの名前空間という機能によりコンテナのプロセスごとに独立したファイルシステムを持つため、コンテナ（プロセス）が削除され、新たにコンテナ（プロセス）が作成されると全く別の名前空間が作成され、そのファイルシステムを利用するためファイルの引継ぎはできないです。
コンテナを作成し、コンテナ内にファイルを作成したあと、コンテナ内から抜けます。
```bash
$ docker container run -dit --name alpine-linux alpine
20f9fdf613b700adb2424d157c5b04dcd24a25daea42e1f015af6a3691cb262d

$ docker container ls
CONTAINER ID   IMAGE     COMMAND     CREATED         STATUS         PORTS     NAMES
20f9fdf613b7   alpine    "/bin/sh"   2 seconds ago   Up 2 seconds             alpine-linux

$ docker container exec -it alpine-linux /bin/sh
/ # touch ~/text.txt
/ # ls ~/text.txt
/root/text.txt
/ # exit
```
コンテナを停止し、削除します。

```bash
$ docker container stop alpine-linux
alpine-linux

$ docker container rm alpine-linux
alpine-linux
```

再度、同じコンテナを作成してコンテナ内に入って先ほど作成したファイルを確認しようとすると、**/root/text.txt: No such file or directory**と表示されファイルが引き継がれていないことが確認できます。
```bash
$ docker container run -dit --name alpine-linux alpine
770665894aaf569c4d06a84312888321db59dfdaa24cf6e4eb643416e5eecfbe

$ docker container ls
CONTAINER ID   IMAGE     COMMAND     CREATED         STATUS         PORTS     NAMES
770665894aaf   alpine    "/bin/sh"   7 seconds ago   Up 6 seconds             alpine-linux

$ docker container exec -it alpine-linux /bin/sh
/ # ls ~/text.txt
ls: /root/text.txt: No such file or directory
/ # exit
```

コンテナ内で作成したデータをホスト上に保存したい、別のコンテナからも共有して使用したいといったデータの永続性を実現するための技術としてDockerはいくつかのマウント機能を提供している。

## マウント
### volume
Docker によって管理されているホストファイルシステム上の一部にデータを保管します。Linuxホスト上では **/var/lib/docker/volumes**ディレクトリ配下を使用します。**docker volume ls**コマンドを実行することで、volumeの一覧を確認することができます。また、**docker volume create**コマンドを実行することで、新規のボリュームを作成することができ、ボリュームの詳細情報を確認したい場合は**docker volume inspect**コマンドを実行することで、確認することができます。

```bash
$ docker volume ls
DRIVER    VOLUME NAME

$ docker volume create vm1
vm1

$ docker volume ls
DRIVER    VOLUME NAME
local     vm1

$ docker volume inspect vm1
[
    {
        "CreatedAt": "2025-01-31T21:07:16Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/vm1/_data",
        "Name": "vm1",
        "Options": null,
        "Scope": "local"
    }
]
```

ボリュームを作成すると、ホスト側の**/var/lib/docker/volumes**ディレクトリ配下に新たに**vm1**ディレクトリが作成され、このディレクトリとコンテナ内がマウントされます。
```bash
$ sudo ls -ltr /var/lib/docker/volumes/vm1/
total 0
drwxr-xr-x. 2 root root 6 Jan 31 21:07 _data
```

ボリュームが作成されたので、コンテナを作成し、ボリュームマウントしていきます。コンテナにボリュームをマウントさせるためには、**docker container run**コマンドに「--mount」オプションを付与します。「--mount」オプションには、いくつか引数をとります。**type**には、マウントの種類を指定します。今回はボリュームマウントのため、**type=volume**を指定します。**src**には、作成したボリューム名を指定します。今回は**src=vm1**を指定します。**target**には、マウントに利用するコンテナのフォルダを指定します。今回は**target=/home**としました。
```bash
$ docker container run -dit --name alpine-linux1 --mount type=volume,src=vm1,target=/home alpine
9d08bc94b020ffb145fb958249c6206e6a271cce095501db47534175dfe68ef5
```

ボリュームマウントをしてコンテナを起動したあと、コンテナ内に入り、マウントしたディレクトリ配下で**test.txt**ファイルを作成し、コンテナから抜けます。その後、コンテナを停止・削除した後、再度ボリュームマウントをしてコンテナを起動し先ほど作成したファイルを確認すると無事に**test.txt**ファイルが確認できました。
```bash
$ docker container exec -it alpine-linux1 /bin/sh
/ # cd /home
/home # touch test.txt
/home # ls test.txt
test.txt
/home # exit

$ docker container stop alpine-linux1
alpine-linux1

$ docker container rm alpine-linux1
alpine-linux1

$ docker container run -dit --name alpine-linux1 --mount type=volume,src=vm1,target=/home alpine
f4647b31d7eead2d4a24dc9306dec81989446816814b397edb4dcac5d23482b2

$ cd /home

$ docker container exec -it alpine-linux1 /bin/sh
/ # cd /home
/home # ls test.txt 
test.txt
```

Docker によって管理されているホストファイルシステム上（**/var/lib/docker/volumes**ディレクトリ配下）を確認すると、コンテナ内で作成した**test.txt**ファイルが存在することが確認できます。よって、コンテナ内で作成されたファイルはDocker によって管理されているマウント先に存在することになり、コンテナが削除され、再度別のコンテナを起動しても同じマウント先を指定することにより永続化することができます。
```bash
$ sudo ls -ltr /var/lib/docker/volumes/vm1/_data
total 0
-rw-r--r--. 1 root root 0 Jan 31 21:26 test.txt
```

作成したボリュームは、**docker volume rm**コマンドを利用することで削除することができます。
```bash
$ docker volume ls
DRIVER    VOLUME NAME
local     vm1

$ docker volume rm vm1
vm1

$ docker volume ls
DRIVER    VOLUME NAME
```

### bind mount

### tmpfs
tmpfsマウントは、Linuxホストマシン上のメモリ空間上にマウントします。ホストマシン上の**メモリ**を利用するためアクセスは高速になりますが、コンテナを停止したり、ホストマシン上も停止や再起動をするとデータが消えてしまいます。
tmpfsマウントさせるためには、**docker container run**コマンドに「--mount」オプションに**type=tmpfs**を指定します。**target**は、今回も**target=/home**としました。コンテナを起動後、コンテナ内で**df -h**コマンドを実行すると**/home**配下がtmpfsをマウントしていることがで確認できます。
```bash
$ docker container run -dit --name alpine-linux1 --mount type=tmpfs,target=/home alpine
c1ce74087a6284c6f2dafa849aaf1c562adb6353de2cbffc9226d56d72a5e9f4

$ docker container exec -it alpine-linux1 /bin/sh
/ # df -h
Filesystem                Size      Used Available Use% Mounted on
overlay                  19.7G      3.7G     16.1G  19% /
tmpfs                    64.0M         0     64.0M   0% /dev
shm                      64.0M         0     64.0M   0% /dev/shm
tmpfs                     1.8G         0      1.8G   0% /home
/dev/sda2                19.7G      3.7G     16.1G  19% /etc/resolv.conf
/dev/sda2                19.7G      3.7G     16.1G  19% /etc/hostname
/dev/sda2                19.7G      3.7G     16.1G  19% /etc/hosts
tmpfs                     1.8G         0      1.8G   0% /proc/acpi
tmpfs                    64.0M         0     64.0M   0% /proc/kcore
tmpfs                    64.0M         0     64.0M   0% /proc/keys
tmpfs                    64.0M         0     64.0M   0% /proc/timer_list
tmpfs                     1.8G         0      1.8G   0% /proc/scsi
tmpfs                     1.8G         0      1.8G   0% /sys/firmware
```